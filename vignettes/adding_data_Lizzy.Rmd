---
title: Adding data to AusTraits
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Adding data to AusTraits}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  results = "asis",
  echo=FALSE, 
  message=FALSE, 
  warning=FALSE
  )

library(austraits.build)
library(dplyr)
library(readr)

root.dir = rprojroot::find_root("remake.yml")
knitr::opts_knit$set(root.dir = root.dir)

my_kable_styling <- my_kable_styling_html
```

```{r, echo=FALSE, results='hide', message=FALSE}
## Assumes to items exist in global name space
if(!exists("austraits")) {
  austraits <- readRDS("export/data/austraits.rds")
  # stop("austraits must exist in global name space to knit a report")
}

definitions <- austraits$definitions
```

This sections explains how to format files to contribute a new study to AusTraits. Before starting this, you should read more about the [structure of the compiled AusTraits database](austraits_structure.md), the [structure of the raw data files](austraits_raw_data.md), and [how to build AusTraits](building_austraits.md).

It is important that all steps are followed so that our automated workflow proceeds without problems. 

The main steps are:

1. Clone the `austraits.build` repository from github and create a new branch in the repo with the name of your dataset_id. 
2. Create a new folder within the folder `data` with a name of the `dataset_id`, e.g. `Gallagher_2014`.
3. Prepare the files `data.csv` and `metadata.yml` and place them within the folder.
4. Add the new study into the build framework and rebuild AusTraits.
5. Run tests on the contributed data and correct the `data.csv` and `metadata.yml`files as necessary.
6. Generate and proofread a report on the data. In particular, check that numeric trait values fall within a logical range relative to other studies and that individual trait observations are not unnecessarily excluded because their trait values are unsupported.
7. Return to step 3 if changes are made to the `data.csv` or `metadata.yml` files.
8. Push to GitHub.

It may help to download one of the [existing datasets](https://github.com/traitecoevo/austraits/tree/master/data) and use it as a template for your own files and a guide on required content. You should look at the files in the [config folder](https://github.com/traitecoevo/austraits/tree/master/config), in particular the `definitions` files for the list of traits we cover and the supported trait values for each trait. Or read through information on the supported traits and trait values.

Once you have prepared your `data.csv` and `metadata.yml` files within a folder in the `data` directory, you can incorporate the new data into Austraits by running:

```{r, eval=FALSE, echo=TRUE}
austraits_rebuild_remake_setup()
```

This step updates the file `remake.yml` with appropriate rules for the new dataset; similarly if you remove datasets, do the same. (At this stage, [remake](https://github.com/richfitz/remake) offers no looping constructs so for now we generate the remake file using [whisker](https://github.com/edwindj/whisker).)

You can then rebuild Austraits, including your dataset.

# Getting started

The `austraits.build` repository includes a bunch of functions that help build the repository. To use these, you'll need to make them available. 

The easiest way is to load the functions into your workspace is to run the following (from within the repository)

```{r, eval=FALSE}
devtools::load_all()
```

# Inputting data

## Constructing the `data.csv` file

All data for a study (`dataset_id`) must be merged into a single spreadsheet, `data.csv`. 

1. Columns must include `taxon name`, `site name` (if appropriate), `contexts` (if appropriate; as one or more columns), and `sample date` (if appropriate). Trait data can be in either a wide format (1 column for each trait, with `trait name` as the column header) or long format (1 column for all `trait values` and additional columns for `trait name` and `units`)

2. If multiple spreadsheets of data are submitted these must be merged together.
    a. If the spreadsheets include different trait measurements made on the same individual (or site means for the same species), they are best merged using `full_join`, specifying all conditions that need to be matched across spreadsheets (e.g. individual, species, site, context). Ensure the column names are identical between spreadsheets or specify  columns that need to be matched.
 ```{r, eval=FALSE, echo=TRUE} 
 read_csv("data/dataset_id/raw/data_file_1.csv) -> data_1
 read_csv("data/dataset_id/raw/data_file_2.csv) -> data_2
 data_1 %>%
    full_join(data_2, by =c("Individual","Taxon","Site","Context"))
 ```
    b. If the spreadsheets include trait measurements for different individuals (or possibly data at a different scale - such as individual level data for some traits and species means for other traits), they are best merged using `bind_rows`. Make sure the column header for taxon name, site name, context, individual, and sample date are identical between spreadsheets. If the same traits have been measured by both studies, 


b. Taxon names need to be complete names. If the main data file includes code names, with a separate file with a key, they need to be merged:
    ```{r, eval=FALSE, echo=TRUE}
    read_csv("data/dataset_id/raw/species_key.csv) -> species_key     
    read_csv("data/dataset_id/raw/data_file.csv) %>%
    left_join(species_key,by="code") %>%
    write_csv("data/dataset_id/data.csv)
    ```


<!-- Lizzy - add details -->

## Constructing the `metadata.yml` file

One way to construct the `metadata.yml` file is to use one of the existing files and modify yours to follow the same format. As a start, checkout some examples from [existing studies in Austraits](https://github.com/traitecoevo/austraits/tree/master/data), e.g. [Angevin_2010](https://github.com/traitecoevo/austraits/blob/master/data/Angevin_2010/metadata.yml) or [Wright_2004](https://github.com/traitecoevo/austraits/blob/master/data/Wright_2004/metadata.yml).

Note, when editing the `metadata.yml`, edits should be made in a proper text editor (Microsoft word tends to stuff up the formatting). For example, Rstudio, textmate, sublime text, and Visual Studio Code are all good editors.

To assist you in constructing the `metadata.yml` file, we have developed functions to help fill in the different sections of the file. If you wish to include additional elements, you can afterwards edit the file further.

To use the functions, make sure you first run the following, to make the functions available

```{r, eval=FALSE, echo=TRUE}
library(austraits.build)
```
OR
```{r, eval=FALSE, echo=TRUE}
devtools::load_all()
```

### Creating a template

The first function creates a basic template for your the `metadata.yml` file for your study. Assuming you have already created a file `data.csv` in the folder `data/your_dataset_id`, run

```{r, eval=FALSE, echo=TRUE}
metadata_create_template(dataset_id)
```

The function will ask a series of questions and then create a relatively empty file `data/your_dataset_id/metadata.yml`. The key questions are:

* Is the data long vs wide? A wide dataset has each variable(i.e. trait ) as a column. A long dataset has each variable as a row and column as a species. 
* Select column for `species_name`
* Select column for `site_name`
* Select column for `context_name`


### Adding a source

Three functions are available to help entering citation details for the source data.

The function `metadata_create_template` creates a template for the primary source with default fields for a journal article, which you can then edit manually.

Alternatively, if you have a `doi` for your study, use the function:

```{r, eval=FALSE, echo=TRUE}
metadata_add_source_doi(dataset_id, doi)
```
and the different elements within source will automatically be generated. By default, details are added as a primary source. To override this, specify the type

```{r, eval=FALSE, echo=TRUE}
metadata_add_source_doi(dataset_id, doi, type="secondary")
```

Alternatively, if you have reference details saved in a bibtex file called `myref.bib` you can use the function

```{r, eval=FALSE, echo=TRUE}
metadata_add_source_doi(dataset_id, file = "myref.bib")
```

(These options require the package [rcrossref](https://github.com/ropensci/rcrossref) and [RefManageR](https://github.com/ropensci/RefManageR/) to be installed.)

### Adding people

The function `metadata_create_template` creates a template for entering details about people, which you can then edit manually.

### Custom R code

Occasionally all the changes we want to make to dataset may not fit into the prescribed workflow used in Austraits. For example, we assume each trait has a single unit. But there are a few datasets where data on different rows have different units. So we want to make to make some custom modifications to this particular dataset before the common pipeline of operations gets applied. To make this possible, the workflow allows for some custom R code to be run as a first step in the processing pipeline. That pipeline (in the function [`load_study`](https://github.com/traitecoevo/austraits/blob/master/R/steps.R)) looks like this:

```{r, eval=FALSE, echo=TRUE}
  data <- 
    read_csv(filename_data_raw, col_types = cols()) %>%
    custom_manipulation(metadata[["config"]][["custom_R_code"]])() %>%
    parse_data(dataset_id, metadata) %>%
    ...
```

Note the second line. This is where the custom code get's applied, right after the file is loaded.

Here is the code that was included in [data/Blackman_2010/metadata.yml](https://github.com/traitecoevo/austraits/blob/master/data/Blackman_2010/metadata.yml) under `custom_R_code`.

```{r, eval=FALSE, echo=TRUE}
data %>% mutate(
    site = ifelse(site == "Mt Field" & habitat == "Montane rainforest", "Mt Field_wet", site),
    site = ifelse(site == "Mt Field" & habitat == "Dry sclerophyll", "Mt Field_dry", site)
    )
```

This is the finished solution. This code gets run everytime we rebuild the Blackman_2010 dataset.

To get there we did as follows. Generally, the custom R ccode should 

- assume a single object called `data`, and apply whatever fixes are needed
- use functions from the packages [dplyr](https://dplyr.tidyverse.org) or [`tiydr`](https://tidyr.tidyverse.org), like `mutate`, `rename`, etc, and otherwise avoid extrenal packages
- be fully self contained (we're not going to use any of the other remake machinery here)
- use pipes to weave together a single statement, where possible. (Otherwise you'll need a semi colons `;` at the end of each statement).

First, load an object called `data` to play with, as if you were building this dataset object:

```{r, eval=FALSE, echo=TRUE}
library(readr)
library(yaml)

data <- read_csv(file.path("data", "Blackman_2010", "data.csv"), col_types = cols(.default = "c"))
data
```

Second, write your code to manipulate data, like the example above.

Third, once you have some working code, you then want to add it into your yml file under a group `config` -> `custom_R_code`. 

Finally, check it works. Let's assume you added it in. The function `metadata_check_custom_R_code` loads the data and applies the custom R code:

```{r, eval=FALSE, echo=TRUE}
metadata_check_custom_R_code("Blackman_2010")
```

### Defining traits

Add traits

```{r, eval=FALSE, echo=TRUE}
metadata_add_traits(dataset_id)
```
<!-- TODO: You will be asked to indicate the columns you wish to keep as distinct traits -->

### Adding site details

Add sites details

```{r, eval=FALSE}
metadata_add_sites(dataset_id, site_data)
```

This function assumes you have site details stored in wide format, in R, such as 

```{r, echo=FALSE, results="markup"}
austraits$sites %>% 
  filter(dataset_id == "Falster_2005_1") %>% 
  select(-dataset_id) %>% 
  spread(site_property, value) %>% 
  type_convert()
```

If your data is in a file, you'll need to read it in first.

### Context details

Add contexts details

```{r, eval=FALSE}
metadata_add_contexts(dataset_id, context_data)
```

This function assumes you have context details stored in wide format, in R, such as 

<!-- TODO: need to indicate that the following code needs to be run with the assignment context_data for the previous code to work. --> 

```{r, echo=FALSE, results="markup"}
austraits$contexts %>% 
  filter(dataset_id == "Hall_1981") %>% 
  select(-dataset_id) %>% 
  spread(context_property, value) %>% 
  type_convert()
```

If your data is in a file, you'll need to read it in first.

### Using substitutions

Substitutions can be added by running:

```{r, eval=FALSE, echo=TRUE}
metadata_add_substitution(dataset_id, trait_name, find, replace)
```

where `find` is the trait value used in the data.csv file and `replace` is the trait value supported by Austraits.

# Quality checks
Before starting the quality checks, it is helpful to assign a variable, `current_study`:
```{r, eval=FALSE, echo=TRUE}
current_study <- "Wright_2001"
```

Note: Yo need to run tests and fix formatting before running `metadata_check_taxonomy()`.

## Running tests {#running_tests}

You begin by running some automated tests to ensure the dataset meets required set up. The tests run through a collection of pre-specified checks on the files for each study. The output alerts you to possible issues needing to be fixed, by comparing the data in the files with expected structure and allowed values, as specified in the definitions. By far the most common error is that there are unusual text characters, for example often special hyphen's, quote symbols, degree symbols, plus-minus symbols, and non-English alphabet characters. These should be replaced by simple text equivalents. It also identifies mis-matches between the site names in the data.csv file vs. metadata.yml file (same for context), unsupported trait names, etc. 

To run the tests, the variable `dataset_ids` must be defined in the global namespace, containing a vector of ids to check. For example

```{r, eval=FALSE, echo=TRUE}
# load relevant functions
source("R/setup.R")

# Tests run test on one study
dataset_ids <- "Bragg_2002"
austraits_run_tests()

# Tests run test on one study using `current_study` variable
dataset_ids <- current_study
austraits_run_tests()

# Tests run test on all studies
dataset_ids <- dir("data")
austraits_run_tests()
```
Fix as many errors as you can and then rerun `austraits_run_tests()` repeatedly until no errors remain. See below for suggestions to implement large numbers of trait value substitutions.

## Clear formatting

This code inserts line breaks every 80 characters, removes other line breaks, and identifies more special characters in the text.

```{r, eval=FALSE, echo=TRUE}
f <- file.path("data", current_study, "metadata.yml")
read_yaml(f) %>% write_yaml(f)
```

Rerun `austraits_run_tests()` until there are again no errors

## Rebuild AusTraits

Now incorporate the new study into AusTraits:

```{r, eval=FALSE, echo=TRUE}
austraits <- remake::make("austraits")
```

## Check excluded data
AusTraits automatically excludes data for a number of reasons.  These are available in the frame `excluded_data`. 

When you are finished running quality checks, no data should be excluded due to *Missing unit conversion* and *Unsupported trait*. 
A few values may be legitimately excluded due to other errors, but check each entry. 

The best way to view excluded data for a study is:

```{r, eval=FALSE, echo=TRUE}
View(filter(austraits$excluded_data,dataset_id==current_study & error!="Missing value" & error!="Observation excluded in metadata"))
```

Or, if you want to check missing values and intentionally excluded metadata:

```{r, eval=FALSE, echo=TRUE}
View(filter(austraits$excluded_data,dataset_id==current_study))
```

### Reasons data are excluded

Possible reasons for excluding trait value include:

- *Missing species name*: Species name missing from data.csv file for a given row of data. This usually occurs when there are stray characters in the data.csv file below the data – delete these rows.
- *Missing value*: Value was missing. Do nothing – these almost always represent honestly missing data. Large numbers of missing values are often present if two dataframes with values for different traits are connected together with `bind_rows()`. 
- *Missing unit conversion*: Value was present but appropriate unit conversion was missing -> you need to add it to the file `config/unit_conversions.csv`. Add additional conversions near similar unit conversions already in the file for easier searching in the future. 
- *Observation excluded in metadata*: Specific values, usually certain taxon names can be excluded in the metadata. This is generally used when a study includes a number of non-native and non-naturalised species that need to be excluded.
- *Time contains non-number*: Indicates a problem with the value entered into the traits `flowering_time` and `fruiting_time`. This error generally occurs because Excel drops leading zeros in data.csv file and will be fixed when these traits are edited to be a sequence of Y’s and N’s instead of 1’s and 0’s.
- *Unsupported trait*: `trait_name` not listed in `config/definitions.yml`, under `traits`. Double check you have used the correct spelling/exact syntax for the `trait_name`, adding a new `trait` to the `definitions` file if appropriate.
- *Unsupported trait value*: This errors, referencing categorical traits, means the `value` for a trait is not included in that traits list of allowable trait values in `config/definitions.yml`. See `Adding many substitutions` if these are many trait values requiring substitutions.
- *Value does not convert to numeric*: Is there a strange character in the file preventing easy conversion? This error is rare and generally justified.
- *Value out of allowable range*: This error, referncing numeric traits, means the trait value, after unit conversions, falls outside of the allowable range specified for that trait in `config/definitions.yml`. Sometimes the AusTraits range is too narrow and other times the author’s value is truly an outlier that should be excluded. Look closely at these and adjust the range in `config/definitions.yml` if justified. Generally, don’t change the range until you’ve create a report for the study and confirmed that the general cloud of data aligns with other studies as excepted. Most frequently the units or unit conversion is what is incorrect.

##Adding many substitutions
For categorical traits, if you want to create a list of all values that require substitutions:

```{r, eval=FALSE, echo=TRUE}
filter(austraits$excluded_data,dataset_id==current_study & error=="Unsupported trait value" %>%
distinct(trait_name,value) %>% 
write_csv("data/dataset_id/raw/substitutions_required.csv")
```
For studies with a small number of substitutions, add them individually, using `metadata_add_substitution(dataset_id,trait_name,find,replace)`

For studies with large number of substitutions required, you can fill in all the correct trait values into this spreadsheet, for instance in Excel, and then read the list of substitutions directly into the metadata file.

```{r, eval=FALSE, echo=TRUE}
read_csv("data/dataset_id/raw/substitutions_required_after_editing.csv") %>%
select(dataset_id = dataset_id, find = column_with_unsupported_value, replace = column_with_AusTraits_aligned_value, trait_name = trait_name) %>% 
pmap_lgl(metadata_add_substitution)
```

Other ways to review excluded data:
How many of each type:

```{r, echo=TRUE, results="show"}
austraits$excluded_data %>% 
  filter(dataset_id=="ANBG_2019") %>%
  pull(error) %>% table()
```

How many of each type by trait:

```{r, echo=TRUE, results="show"}
austraits$excluded_data %>% 
  filter(dataset_id=="ANBG_2019") %>%
  select(trait_name, error) %>%
  table()
```


### Update taxonomy
The species names used in a given dataset must be aligned with the currently accepted APC/APNI taxonomy used in AusTraits. 

The AusTraits config files include a list that includes all taxa currently recognised by APC/APNI and their outdated/obsolete taxonomic names. Outdated names are automatically aligned with currently recognised taxonomy,

To check if there are any unrecognised taxon names in the study, use: 

```{r, eval=FALSE, echo=TRUE}
  metadata_check_taxa(dataset_id = current_study)
```
(If there are stray special characters in the metadata file, your metadata file will be truncated at the first special character encountered, so only run this function after you have cleared formatting and run tests to ensure you've caught all special characters.)

This function aligns slightly misspelled names through fuzzy matching (up to 2 characters different). 

Additional arguments can be added to the function:
```{r, eval=FALSE, echo=TRUE}
metadata_check_taxa <- function(dataset_id, max_distance_abs = 3, max_distance_rel = 0.2, try_outside_guesses = FALSE)
```
- `max_distance_abs` is the maximum number of different characters allowed with fuzzy matching.
- `max_distance_rel` is the maximum proportion of characters that are allowed to be different with fuzzy matching.
- `try_outside_guesses` offers a menu of matching suggestions for each species. Set this as false for the first run of the function – it is best to start with automated matching and use this for a small number of unmatched species at the end.

1.	Run the basic function once to align the easily re-aligned names. 
    a.  Check all substitutions added to the metadata file.
    b.	On occasion there are nonsensical realignments due to fuzzy matching. Delete these and manually add the correct alignment.
2.	Run the function a second time to see which names (if any) couldn’t be easily matched. 
    a.	Do nothing about names recorded only to the genus level (e.g. Acacia sp.). Names formatted as `genus sp.` or `genus sp. [characters]` are recognised as members of the genus Acacia. Add manual substitutions (see below) to reformat all genus-level observations to `genus sp. [characters]`. For instance, `Acacia sp.` or `Acacia sp. [long leaf]` not `long leaf Acacia species`
    b.	If there are unrecognised names that you know are non-naturalised species (i.e. horticultural plants, measurements made outside Australia on a non-native species), exclude them in the metadata. For instance, from eFLOWER_2021:
    ` 
      - variable: taxon_name
        find: Elatine triandra, Galbulimima belgraveana, Hydrocotyle vulgaris, Pennantia corymbosa, Strychnos nux-vomica, Galbulimima baccata
        reason: These are 'misapplied' species that are unlikely to actually be Australian species
    `
    c.	If there are unrecognized phrase names, use the APC/APNI website (https://biodiversity.org.au/nsl/services/search/taxonomy; use ‘%’ as a wildcard character) to search for the recognized syntax and add it as a substitution under `taxonomic_updates`. For instance, from White_2020:
    `
      - find: Celmisia 'pulchella'
        replace: Celmisia sp. Pulchella (M.Gray & C.Totterdell 7079)
        reason: Alignment with known name in APC list (accepted) (Elizabeth Wenk, 2020-06-30)
    `
    d.	For hybrid species look through the files under `config\NSL` for examples or the extensive list of substitutions in White_2020.
3.	Add substitutions manually to the metadata.yml file or via the function:
    ```{r, eval=FALSE, echo=TRUE}
    metadata_add_taxonomic_change(study, find, replace, reason)
    ```
    For a study requiring a large number of taxonomic changes, you can create a dataframe with headers `dataset_id`, `find` (original name), `replace` (APC/APNI accepted name), and `reason` and run:
    ```{r, eval=FALSE, echo=TRUE}
    read_csv("data/dataset_id/raw/taxonomic_changes_to_implement.csv") %>%
    select(dataset_id = dataset_id, find = find, replace = replace, reason = reason) %>% 
    pmap_lgl(metadata_add_taxonomic_change)
    ```
4.	Occasional studies report phrase names that aren’t in the APC/APNI lists, but are present in the ALA (Atlas of Living Australia) database. In this case, format the name to match the accepted phrase name format. The name will be remain unrecognized by AusTraits.

## Check for duplicates
AusTraits strives to have no duplicate numeric (continuous) trait measurements. 

When you receive/solicit a dataset, ask the data contributor if all data submitted was collected for the specific study. 

In addition, there are tests to check for duplicates within and across dataset_ids.

To check for duplicates:
```{r, eval=FALSE, echo=TRUE}
austraits_deduped <- remove_suspected_duplicates(austraits)
duplicates_for_dataset_id  <- filter(austraits_deduped$excluded_data,dataset_id==current_study & error !="Missing value")
View(duplicates_for_dataset_id)
```

###Duplicates within the study
1.	First sort `duplicates_for_dataset_id` by the column `error` and scan for duplicates within the study (these will be entries under error that begin with the same `dataset_id` as the dataset being processed)
2.	For legitimate duplicates, do nothing. For instance, if %N has been measured on 50 replicates of a species and is reported to the nearest 0.01% it is quite likely there will be a few duplicate values within the study.
3.	If a species-level measurement has been entered for all within-site replicates, you need to filter out the duplicates. This is true for both numeric and categorical values. Enter the following code as `extra R code` in the dataset's metadata file. (Using custom R code instead of filtering the values in the data.csv file itself, ensures the relevant trait values are still associated with each line of data in the data.csv file, but only read into AusTraits a single time.)
```{r, eval=FALSE, echo=TRUE}
data %>% group_by(Species) %>%
mutate_at(vars(leaf_percentN, `plant growth form`),~replace(.x,duplicated(.x),NA)) %>%
ungroup()
```
Note: You would use `group_by(Species,Site)` if the duplication is at the species x site level.

###Duplicates between studies
AusTraits does not attempt to filter out duplicates in categorical traits between studies. The commonly duplicated traits like `life_form`, `plant_growth_form`, `photosynthetic_pathway`, `fire_response`, etc. are legitimately duplicated and if   the occasional study reported a different `plant_growth_form` or `fire_response` it would be important to have documented that one trait_value was much more common than another. Such categorical trait values may have been sourced from a reference material or measured/identified by this research team.

Identifying duplicates in numeric traits between studies can be difficult. Some common patterns of duplication include:
   1. For a single trait, if there are a large number of values duplicated in a specific other dataset_id (i.e. the `error` repeatedly starts with the same `dataset_id`), be suspicious. Before contacting the author, check the metadata for the two datasets, especially authors and study locations, to see if it is likely these are data values that have been jointly collected and shared across studies. Similar site names/lcations, identical university affiliations, or similar lists of traits being measured are good clues.
   2. `plant_height`, `leaf_length`, `leaf_width`, `seed_length`, `seed_width` and `seed_mass` are the numeric variables that are most frequently sourced from reference-books (e.g. floras, herbarium collections, reference books, Kew seed database, etc.) 
   3. The following datasets are flagged in AusTraits as `reference` studies and are the source of most duplicates for the variables listed above:
   `Kew_2019_1`, `Kew_2019_2`, `Kew_2019_3`, `Kew_2019_4`, `Kew_2019_5`, `Kew_2019_6`, `ANBG_2019`, `GrassBase_2014`, `CPBR_2002`, `NTH_2014`,`RBGK_2014`, `NHNSW_2016`, `RBGSYD__2014_2`, `RBGSYD_2014`, `TMAG_2009`, `WAH_1998`, `WAH_2016`,`Brock_1993`, `Barlow_1981`, `Hyland_2003`, `Cooper_2012`
   4. Data for `wood_density` is also often sourced from other studies, most commonly `Ilic_2000` or `Zanne_2009`.
   5. Data from a number of studies from `Leishman` and `Wright` have been extensively shared within the trait ecology community, especially through TRY

If the dataset you are processing has a large number of numeric trait duplicates that follow one of the `patterns of duplication` listed, the duplicates should be filtered out. Any other data indicated in the manuscript as `sourced` should also be filtered out. Most difficult are studies that have partially sourced data, often from many small studies, and partially collected new data, but not identified the source of each value.

Filtering duplicate data is a three-step process. In brief:
1. Identify traits and studies with duplicates you believe should be removed.
2. Add additional columns to `data.csv` for the study you are processing, identifying certain `trait_values` as duplicates.
3. Add `custom R code` that filters out identified duplicates when the study is merged into AusTraits.

In detail:
####Identify traits and studies
1. Either in R or Excel, manipulate `duplicates_for_dataset_id` to remove rows that you believe are legitimate duplicates, including duplicates within the same study and instances when a single value (or a few) are duplicated with a study. Carefully consider which datasets and trait's to include/exclude from the filter. 
As an example:
```{r, eval=FALSE, echo=TRUE}
duplicates_for_dataset_id %>%
  mutate(dataset_with_duplicate = gsub("Duplicate of ","",error),
         dataset_with_duplicate = gsub("[[:alnum:]]$","",dataset_with_duplicate),
         dataset_with_duplicate = gsub("[[:alnum:]]$","",dataset_with_duplicate),
         dataset_with_duplicate = gsub("[[:alnum:]]$","",dataset_with_duplicate),
         dataset_with_duplicate = gsub("[[:alnum:]]$","",dataset_with_duplicate),
         dataset_with_duplicate = gsub("[[:alnum:]]$","",dataset_with_duplicate),
         dataset_with_duplicate = gsub("[[:punct:]]$","",dataset_with_duplicate)
         ) %>%
  filter(dataset_with_duplicate %in% c("Ilic_2000","Zanne_2009","Kew_2019_1","Barlow_1981","NTH_2014")) %>%
  filter(trait_name %in% c("wood_density","seed_mass","leaf_length","leaf_width")) -> duplicates_to_filter
```
2. Use the following code to add columns to `data.csv` that identify specific values as duplicates:
```{r, eval=FALSE, echo=TRUE}
wood_density_duplicates <- duplicates_to_filter %>% 
  filter(trait_name == "wood_density") %>% 
  select(error, original_name) %>% 
  rename(wood_density_duplicate = error)

seed_mass_duplicates <- duplicates_to_filter %>% 
  filter(trait_name == "seed_width") %>% 
  select(error, original_name) %>% 
  rename (seed_mass_duplicate = error)

leaf_width_min_duplicates <- duplicates_to_filter %>% 
  filter(trait_name == "leaf_width" & value_type == "expert_min") %>% 
  select(error, original_name) %>% 
  rename (leaf_width_min_duplicate = error)

leaf_width_max_duplicates <- duplicates_to_filter %>% 
  filter(trait_name == "leaf_width" & value_type == "expert_max") %>% 
  select(error, original_name) %>% 
  rename (leaf_width_max_duplicate = error)

leaf_length_min_duplicates <-duplicates_to_filter %>% 
  filter(trait_name == "leaf_length" & value_type == "expert_min") %>% 
  select(error, original_name) %>% 
  rename (leaf_length_min_duplicate = error)

leaf_length_max_duplicates <- duplicates_to_filter %>% 
  filter(trait_name == "leaf_length" & value_type == "expert_max") %>% 
  select(error, original_name) %>% 
  rename (leaf_length_max_duplicate = error)

read_csv("data/dataset_id/data.csv") %>%
  left_join(wood_density_duplicates, by = c("column_with_species_name" = "original_name")) %>% 
  left_join(seed_mass_duplicates, by = c("column_with_species_name" = "original_name")) %>% 
  left_join(leaf_width_min_duplicates, by = c("column_with_species_name" = "original_name")) %>% 
  left_join(leaf_width_max_duplicates, by = c("column_with_species_name" = "original_name")) %>% 
  left_join(leaf_length_min_duplicates, by = c("column_with_species_name" = "original_name")) %>% 
  left_join(leaf_length_max_duplicates, by = c("column_with_species_name" = "original_name")) %>% 
write_csv("data/dataset_id/data.csv")
```
3. For the above example, add the following code to custom R code:
```{r, eval=FALSE, echo=TRUE}
data %>%
  mutate(`wood density` = ifelse(is.na(wood_density_duplicate),`wood density`,NA),
         `seed mass (mg)` = ifelse(is.na(seed_mass_duplicate),`seed mass (mg)`,NA),
         `leaf width minimum (mm)` = ifelse(is.na(leaf_width_min_duplicate),`leaf width minimum (mm)`,NA),
         `leaf width maximum (mm)` = ifelse(is.na(leaf_width_max_duplicate),`leaf width maximum (mm)`,NA),
         `leaf length minimum (mm)` = ifelse(is.na(leaf_length_min_duplicate),`leaf length minimum (mm)`,NA),
         `leaf length maximum (mm)` = ifelse(is.na(leaf_length_max_duplicate),`leaf length maximum (mm)`,NA)
  )
```

Difficulties:
•	This method only identifies values as duplicates if they have the same number of significant figures. More complex matching can be done for these. For seed mass in particular, some studies likely source values from the Kew database and then round these values. They may similarly source several values from Kew and then include the mean in their dataset. If their methods or correspondence with the contributor suggests the values were sourced from Kew (or another lab, papers, etc.) I generally filter out all values, EXCEPT, species that are not yet represented in AusTraits. 


## Build study report
A final quality check is generating a report on the data in each study. 

Rebuild the taxon list and AusTraits to ensure other changes made during the quality checks are implemented. Then build the study report:

```{r, eval=FALSE, echo=TRUE}
austraits_rebuild_taxon_list()
austraits <- remake::make("austraits")
build_study_report(current_study)
```

Check the study report to ensure:
•	All possible metadata fields were filled in
•	The sites plot sensibly on the map of Australia
•	For numeric traits, the trait values plot sensibly relative to other studies
•	The list of unknown/unmatched species doesn’t include names you think should be recognized/aligned

If necessary, cycle back through earlier steps to fix any errors, rebuilding the study report as necessary

At the very end, re-clear formatting, re-run tests, rebuild AusTraits, rebuild report. 

If you’re uncertain, also recheck excluded data and duplicates before these final steps.

```{r, eval=FALSE, echo=TRUE}
f <- file.path("data", current_study, "metadata.yml")
read_yaml(f) %>% write_yaml(f)

dataset_ids <- current_study
austraits_run_tests()

austraits <- remake::make("austraits")
build_study_report(current_study,overwrite=TRUE)
```

To generate a report for a collection of studies:
```{r, eval=FALSE, echo=TRUE}
build_study_reports(c("Falster_2005_1", "Wright_2002"),overwrite=TRUE)
```

Or for all studies:

```{r, eval=FALSE, echo=TRUE}
build_study_reports(overwrite=TRUE)
```

Add the argument `overwrite=TRUE` if you already have a copy of a specific report stored in your computer and want to replace it with a newer version.

(Reports are written in [Rmarkdown](https://rstudio.github.io/rmarkdown/) and generated via the [knitr](https://cran.r-project.org/web/packages/knitr/) package. The template is stored in `scripts/report_study.html`).


# Working with our GitHub repository

By far our preferred way of contributing is for you to contribute files directly into the repository and then send a  [pull request](https://help.github.com/articles/using-pull-requests/) with you input. You can do this by

- (for approved maintainers of austraits.build) Creating a branch, or
- (for others) forking the database in github

In short, 

1. Create a Git branch for your new work, either within the AusTraits repo (if you are an approved contributor) or as a [fork of the repo](https://help.github.com/en/github/getting-started-with-github/fork-a-repo). 
2. Make commits and push these up onto the branch. 
2. Make sure everything runs fine before you send a pull request.
3. When you're ready to merge in the new features, 

Before you make a substantial pull request, you should always [file an issue](https://github.com/traitecoevo/austraits.build/issues) and make sure someone from the team agrees that it’s worth pursuing. a problem. If you’ve found a bug, create an associated issue and illustrate the bug with a minimal [reprex](https://www.tidyverse.org/help/#reprex) illustrating the issue.

If this is not possible, you could email the relevant files (see above) to the Austraits email: austraits.database@gmail.com

## Merging a pull request

There are multiple ways to merge a pull request, including using GitHub's built-in options for merging and squashing. When merging a PR, we ideally want

- a single commit
- attributing the work to the original author
- to run various checks along the way 

There's two ways to do this. For both you need to be an approved maintainer. 

### Merging in your own PR

You can merge in your own PR after you've had someone else review it. 

1. Send the PR
2. Tag someone to review
3. Once ready, merge into main choosing "Squash & Merge", using an informative commit message.


### Merging someone else's PR

When merging in someone else's PR, the built-in  options aren't ideal. as they either take all of the commits on a branch (ugh, messy), OR make the commit under the name of the person merging the request.

The workflow below describes how to merge a pull request from the command line, with a single commit & attributing the work to the original author. Lets assume a branch of name `Smith_1995`.

First from the master branch in the repo, run the following:

```
git merge --squash origin/Smith_1995
```

Then in R

```{r, eval=FALSE}
dataset_ids <- "Smith_1995"

# Update remake file
austraits_rebuild_remake_setup()

# check data builds
remake::make(dataset_ids)

# Check taxonomy has been updated
metadata_check_taxa(dataset_ids)

# run tests on dataset
austraits_run_tests()

# read and write yaml to prevent future reformatting 
f <- file.path("data", dataset_ids, "metadata.yml")
read_yaml(f) %>% write_yaml(f)

# rebuild
remake::make(dataset_ids)
```

Now back in the terminal

```
git add .
git commit
```

Add a commit message, referencing relevant pull requests and issues, e.g.

```
Smith_1995: Import new data

For #224, closes #286
```

And finally, amend the commit author, to reference the person who did all the work!
```
git commit --amend --author "XXX <XXX@gmail.com>"
```

## Commit messages

XXXXXX
Informative commit messages are ideal. Where possible, these should link to 



## Version updating & Making a new release

Releaes of the dataset are snapshots that are archived and available for use. 

We use semantic versioning to label our versions. As discussed in [Falster et al 2019](http://doi.org/: 10.1093/gigascience/giz035), semantic versioning can apply to datasets as well as code.

The version number will have 3 components for actual relases, and 4 for development versions. The structure is `major.minor.patch.dev`, where `dev` is at least 9000.  The `dev` component provides a visual signal that this is a development version. So, if the current version is 0.9.1.9000, the release be 0.9.2, 0.10.0 or 1.0.0. 

Our approach to incrmenetaing version numbers is

- `major`: increment when you make changes to the structure that are likely incompatible with any code written to work with previous versions. 
- `minor`: increment to communicate any changes to the structure that are likely to be compatible with any code written to work with the previous versions (i.e., allows code to run without error). Such changes might involve adding new data within the existing structure, so that the previous dataset version exists as a subset of the new version. For tab- ular data, this includes adding columns or rows. On the other hand, removing data should constitute a major version because records previously relied on may no longer exist. 
- `patch`: Increment to communicate correction of errors in the actual data, without any changes to the structure. Such changes are unlikely to break or change analyses
written with the previous version in a substantial way.

<img src="../docs/figures/giz035fig2.png">

**Figure:** Semantic versioning communicates to users the types of changes that have occurred between successive versions of an evolving dataset, using a tri-digit label where increments in a number indicate major, minor, and patch-level changes, respectively. From [Falster et al 2019](http://doi.org/: 10.1093/gigascience/giz035), (CC-BY). 

The process of making a release is as follows. Note that correpsonding releases and versions are needed in both `austraits` and `austraits.build`:

1. Update the version number in the DECRIPTION file, using `

```{r, eval=FALSE}
desc::desc_bump_version()
```

2. Compile `austraits.build`.

3. Update the documentation.

4. Commit and push to github.

5. Make a release on github, adding version number 

5. Prepare for the next version by updating version numbers.

```{r, eval=FALSE}
desc::desc_bump_version("dev")
```

# Other

## File types

### CSV 

A comma-separated values (CSV) file is a delimited text file that uses a comma to separate values. Each line of the file is a data record. Each record consists of one or more fields, separated by commas. This is a comma format for storing tables of data in a simple text file. You can edit it an Excel or in a text editor.For more, see [here](https://en.wikipedia.org/wiki/Comma-separated_values).

### YAML files {#yaml}

The `yml` file extension (pronounced "YAML") [is a type structured data file](https://en.wikipedia.org/wiki/YAML), that is both human and machine readable. You can edit it any text editor, or also in Rstudio. Generally, yml is used in situations where a table does not suit because of variable lengths and or nested structures. It has the advantage over a spreadsheet in that the nested “headers” can have variable numbers of categories. The data under each of the hierarchical headings are easily extracted by R.

## Extracting data from PDF tables

If you encounter a PDF table of data and need to extract values, this can be achieved with the [`tabula-java` tool](https://github.com/tabulapdf/tabula-java/). There's actually an R wrapper (called [`tabulizer`](https://github.com/ropensci/tabulizer)), but we haven't succeeded in getting this running. However, it's easy enough to run the java tool at the command line on OSX.

1. [Download latest release of `tabula-java`](https://github.com/tabulapdf/tabula-java/releases) and save the file in your path

2. Run
```
java -jar tabula-1.0.3-jar-with-dependencies.jar my_table.pdf -o my_data.csv
```
This should output the data from the table in `my_table.pdf` into the csv `my_data.csv`

3. Clean up in Excel. check especially for correct locations of white spaces.
