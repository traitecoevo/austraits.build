---
title: Structure of AusTraits data compilation
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ Structure of AusTraits data compilation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  results = "asis",
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)

library(austraits)
library(dplyr)
library(readr)

root.dir <- rprojroot::find_root("remake.yml")
knitr::opts_knit$set(root.dir = root.dir)

my_kable_styling <- my_kable_styling_html
```

```{r, echo=FALSE, results='hide', message=FALSE}
## Assumes to items exist in global name space
if (!exists("austraits")) {
  austraits <- readRDS("export/data/curr/austraits.rds")
  # stop("austraits must exist in global name space to knit a report")
}

definitions <- austraits$definitions
```


This document describes the structure of the AusTraits compilation, corresponding to **Version `r desc::desc_get_version("./DESCRIPTION")`** of the dataset. 

Note that the information provided below is based on the information provided within the file `definitions.yml`. 

AusTraits is essentially a series of linked components, which cross link against each other::

```{r, results="hide", comment = '', eval=FALSE}
names(austraits) %>%
  create_tree_branch("austraits") %>%
  writeLines()
```

```
austraits
├── traits
├── sites
├── contexts
├── methods
├── excluded_data
├── taxa
├── taxonomic_updates
├── definitions
├── contributors
├── sources
└── build_info
```

These include all the data and contextual information submitted with each contributed dataset. 

## Components

The core components are defined as follows.

```{r}
print_definitions_element <- function(elements) {
  if (elements$type == "character") {
    sprintf("**Content:** %s\n", elements$value) %>%
      writeLines()
  }

  if (elements$type == "table") {
    sprintf("**Content:** \n") %>%
      writeLines()

    elements$elements %>%
      list1_to_df() %>%
      my_kable_styling() %>%
      writeLines()
  }
}

for (v in names(austraits)) {
  elements <- austraits$definitions$austraits$elements[[v]]

  sprintf("### %s {#%s}\n\n**Description:** %s.\n", v, v, elements$description) %>%
    stringr::str_replace_all("\\.\\.", "\\.") %>%
    writeLines()

  elements %>%
    print_definitions_element()

  writeLines(c(""))
}
```

## Dataset IDs

The core organising unit behind AusTraits is the `dataset_id`. Records are organisation as coming from a particular study, defined by the  `dataset_id`. Our preferred format for `dataset_id` is surname of the first author of any corresponding publication, followed by the year, as `surname_year`. E.g. `Falster_2005`. Wherever there are multiple studies with the same id, we add a suffix `_2`, `_3` etc. E.g.`Falster_2005`, `Falster_2005_2`.

## Observation IDs

As well as a `dataset_id`, each trait measurement has an associated `observation_id`.  Observation IDs bind together related measurements within any dataset, and thereby allow transformation between long  (e.g. with variables `trait_name` and `value`) and wide (e.g. with traits as columns) formats.

Generally, `observation_id` has the format `dataset_id_XX` where `XX` is a unique number within each dataset. For example, if multiple traits were collected on the same individual, the `observation_id` allows us to gather these together. For floras, which report a species averages, the `observation_id` is assigned at the species level.

For datasets that arrive in wide format we assume each row has a unique `observation_id`. For datasets that arrive in long format, the `observation_id` is assigned based on a specified grouping variable.  If missing, `observation_id` is assigned based on `species_name`. 

## Site names

As well as `dataset_id` and `observation_id`, where appropriate, trait values are associated with a `site_name`. Unique combinations of `dataset_id` and `site_name` can be used to cross-match against the sites table, which provide further details on the site sampled.

## Context names

As well as `dataset_id`, `observation_id`, and `site_name`, where appropriate, trait values are associated with a `context_name`. Unique combinations of `dataset_id` and `context_name` can be used to cross-match against the context table, which provide further details on the context sampled.

## Values and Value types {#value_types}

Each record in the table of trait data has an associated `value` and `value_type`. 

Traits are either `numeric` or `categorical`. For traits with numerical values, the recorded value has been converted into standardised units and we have checked that the value can be converted into a number and lies within the allowable range.  For categorical variables, we only include records whose values are included as allowable values in a trait's definition in the definitions table. Moreover, we use a format whereby

- we use `_` for multi-word terms, e.g. `semi_deciduous`
- we use a space for situations where a single study reports two possible values for that trait, e.g. `annual biennial` for something which is either annual or biennial 

Each trait measurement also has an associated `value_type`, which is ``r austraits$definitions$value_type$description`` Possible values are:

```{r value_type}
austraits$definitions$value_type$values %>%
  list1_to_df() %>%
  my_kable_styling() %>%
  writeLines()
```

AusTraits does not include intra-individual observations. When multiple measurements per individual are submitted to AusTraits, we take the mean of the values and record the value_type as `individual_mean`.

## Taxonomy {#taxonomic}

Version `r desc::desc_get_field("Version")` of AusTraits contains records for `r austraits$traits$species_name %>% unique() %>% length()` different taxa. We have attempted to align species names with known taxonomic units in the [`Australian Plant Census` (APC)](https://biodiversity.org.au/nsl/services/apc) and/or the [`Australian Plant Names Index` (APNI)](https://biodiversity.org.au/nsl/services/APNI). 

The table `taxa` lists all taxa in the database, including additional information about the taxa (see Table above). 

The `traits` table reports both the original and the updated taxon name alongside each trait record.

The table `taxonomic_updates` provides details on all taxonomic names changes implemented in aligning with APC and APNI.

## Sources

For each dataset in the compilation there is the option to list primary and secondary citations. The primary citation is defined as, ``r austraits$definitions$metadata$elements$source$values$primary`` The secondary citation is defined as, ``r austraits$definitions$metadata$elements$source$values$secondary`` These references are included in two places:

1. Within the table [methods](#methods), where we provide a formatted version of each.
2. In the element [sources](#sources), where we provided bibtex versions of all sources which can be imported into your reference library. The keys for these references are listed within the [methods]{#methods}. 

## Trait definitions

Allowable traits and values are defined in the definitions file. Each trait is 
labelled as either `numeric` or `categorical`. An example of each type is as follows. For the full list, see the section on Trait definitions.


```{r, traits}
for (trait in c("specific_leaf_area", "woodiness")) {
  elements <- austraits$definitions$traits$elements[[trait]]

  data_trait <- austraits$traits %>% filter(trait_name == trait)

  c(sprintf("**%s**\n\n", trait), sprintf("- label: %s", elements$label), sprintf("- description: %s", elements$description), sprintf("- number of records: %s", data_trait %>% nrow()), sprintf("- number of studies: %s", data_trait %>% pull(dataset_id) %>% unique() %>% length()), sprintf("- type: %s%s", elements$type, ifelse(elements$type == "numeric", sprintf("\n- units: %s", elements$units), "")), ifelse(elements$type == "numeric", sprintf("- allowable range: %s - %s %s", elements$values$minimum, elements$values$maximum, elements$units), sprintf("- allowable values:\n%s\n", paste0("    - *", elements$values %>% names(), "*: ", elements$values %>% unlist(), collapse = "\n"))), "") %>% writeLines()
}
```
